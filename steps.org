* Preface
If need be...
#+begin_src jupyter-python
!pip install -r requirements.txt
#+end_src

* Introduction
Here we give a set of generic instructions for analyzing demand for
food and nutrition.  Inputs include a datasets of consumption
quantities, consumption expenditures, household characteristics, and a
food conversion table.

The different datasets should be indexed as follows:

   | Dataset            | Indexed by | Columns |
   |--------------------+------------+---------|
   | Expenditures       | i,t,m      | j       |
   | Consumption        | i,t,m,u    | j       |
   | Prices             | t,m        | j       |
   | HH Characteristics | i,t,m      | k       |
   | FCT                | j,u        | n       |
   | RDI                | n          | k       |

where =i= indexes households, =t= indexes periods, =m= indexes
markets, =j= indexes goods, =k= indexes different kinds of household
characteristics, =u= indexes different unit names, and =n= indexes
different nutrients.  Finally, any RDI ("recommended daily intake")
tables should be indexed by nutrients, with columns corresponding to
characteristics of persons within the household (e.g., age & sex
categories).

Note that some countries have more than one dataframe of consumption,
distinguished by source; for example Malawi has consumption items
purchased as well as consumption items produced.  Here we focus on
consumption purchases, since one of our immediate aims is to infer
prices paid.

* Step 1: Acquire DataFrames

Here are addresses of google sheets for different dataframes for the
case of Uganda:
#+begin_src jupyter-python :tangle /tmp/foo.py
InputFiles = {'Expenditures':('1yVLriVpo7KGUXvR3hq_n53XpXlD5NmLaH1oOMZyV0gQ','Expenditures (2019-20)'),
              'Prices':('1yVLriVpo7KGUXvR3hq_n53XpXlD5NmLaH1oOMZyV0gQ','Prices'),
              'HH Characteristics':('1yVLriVpo7KGUXvR3hq_n53XpXlD5NmLaH1oOMZyV0gQ','HH Characteristics'),
              'FCT':('1yVLriVpo7KGUXvR3hq_n53XpXlD5NmLaH1oOMZyV0gQ','FCT'),
              'RDI':('1yVLriVpo7KGUXvR3hq_n53XpXlD5NmLaH1oOMZyV0gQ','RDI'),}
#+end_src

Note that in some cases not the food items for the FCT (e.g., for Niger) are *not* yet all matched up ("harmonized") with food labels indexed by =j= in the expenditure,
consumption and price datasets.

#+begin_src jupyter-python :tangle /tmp/foo.py
from eep153_tools.sheets import read_sheets
import numpy as np
import pandas as pd

def get_clean_sheet(key,sheet=None):

    df = read_sheets(key,sheet=sheet)
    df.columns = [c.strip() for c in df.columns.tolist()]

    df = df.loc[:,~df.columns.duplicated(keep='first')]   

    df = df.drop([col for col in df.columns if col.startswith('Unnamed')], axis=1)

    df = df.loc[~df.index.duplicated(), :]

    return df

# Get expenditures...
x = get_clean_sheet(InputFiles['Expenditures'][0],
                    sheet=InputFiles['Expenditures'][1])

if 'm' not in x.columns:
    x['m'] = 1

x = x.set_index(['i','t','m'])
x.columns.name = 'j'

x = x.apply(lambda x: pd.to_numeric(x,errors='coerce'))
x = x.replace(0,np.nan)

# Get HH characteristics...
z = get_clean_sheet(InputFiles['HH Characteristics'][0],
                    sheet=InputFiles['HH Characteristics'][1])

if 'm' not in z.columns:
    z['m'] = 1

z = z.set_index(['i','t','m'])
z.columns.name = 'k'

z = z.apply(lambda x: pd.to_numeric(x,errors='coerce'))

# Get prices
p = get_clean_sheet(InputFiles['Prices'][0],
                    sheet=InputFiles['Prices'][1])

if 'm' not in p.columns:  # Supply "market" indicator if missing
    p['m'] = 1

p = p.set_index(['t','m'])
p.columns.name = 'j'

p = p.apply(lambda x: pd.to_numeric(x,errors='coerce'))
p = p.replace(0,np.nan)

fct = get_clean_sheet(InputFiles['FCT'][0],
                    sheet=InputFiles['FCT'][1])

#### This bit peculiar to Niger FCT #####
#fct = fct.loc[fct.Code.str.len()==6]
#fct = fct.set_index('Code')
#fct.columns = [v.replace('\n',' ') for v in fct.columns]
########################################
fct = fct.set_index('j')
fct.columns.name = 'n'

fct = fct.apply(lambda x: pd.to_numeric(x,errors='coerce'))

################## RDI, if available (consider using US) #####################
rdi = get_clean_sheet(InputFiles['RDI'][0],
                    sheet=InputFiles['RDI'][1])
rdi = rdi.set_index('n')
rdi.columns.name = 'k'
#+end_src

* Step 2: Estimate Demand System

Here, use data on log /expenditures/ and household characteristics to
create a CFEDemand =result=.
#+begin_src jupyter-python :tangle /tmp/foo.py
import cfe

result = cfe.Regression(y=np.log(x.stack()),d=z)

result.get_beta().sort_values(ascending=False) # Check sanity...
#+end_src



 Make this persistent...
#+begin_src jupyter-python :tangle /tmp/foo.py
result.to_pickle('./foo.pickle')
#+end_src


* Step 3: Infer quantities

Next, we divide predicted expenditures by prices to get
quantities (in kilograms) we can map into the  FCT.

#+begin_src jupyter-python :tangle /tmp/foo.py
import cfe

result = cfe.read_pickle('foo.pickle')  # Get persistent result saved above...

xhat = result.predicted_expenditures()

# Expenditures divided by prices/kg gives quantities in kgs...
qhat = (xhat.unstack('j')/p).dropna(how='all')

# Drop missing columns
qhat = qhat.loc[:,qhat.count()>0]
#+end_src

Note that =qhat= may give prices for different /units/.  If prices
differ *only* because of units (e.g., one deciliter costs one
tenth as much as a liter), then we can use these differences in prices
to convert between different units, even if the units (e.g., "basket")
is otherwise unclear.  

If we have enough data on purchases in kilograms, just keep those
prices (otherwise choose some other useful unit).  We also assume
prices are the same for everyone, so just take median.

* Step 4: Predicting Positive Consumption :noexport:
An issue with our assessment of fit is that we /predicted/ that every
household would consume positive quantitites of every good, and in
making our assessment we ignored the (many) cases in which in fact the
household had zero expenditures on that good.  

Here we're going to go back and use similar framework to try and
estimate the probability with which we'll observe zero expenditures
as a function of \lambda, prices, and household characteristics.

#+begin_src jupyter-python :tangle /tmp/foo.py
import numpy as np
import matplotlib.pyplot as plt
%matplotlib notebook
import matplotlib.cm as cm
import cfe

zeros_r = cfe.Regressult(y=(0.+(np.exp(result.y)>0)),z=result.z)
weights = zeros_r.get_predicted_log_expenditures()

# Truncate to make weights live in [0,1]
weights = weights.where((weights<1) + np.isnan(weights),1).where((weights>0) + np.isnan(weights),0)

xbar = np.exp(result.y).sum(['m','i']).to_dataframe('xbar').replace(0,np.nan).squeeze()

# Calculate *expected* predicted expenditures, to make unconditional on being positive
xhat = (weights*result.get_predicted_expenditures())
xsum = xhat.sum(['m','i']).to_dataframe('xhat').replace(0,np.nan).squeeze()

# Make dataframe of actual & predicted
df = pd.DataFrame({'Actual':np.log(xbar),'Predicted':np.log(xsum)})

df.plot.scatter(x='Predicted',y='Actual')

# Add 45 degree line
v = plt.axis()
vmin = np.max([v[0],v[2]])
vmax = np.max([v[1],v[3]])
plt.plot([vmin,vmax],[vmin,vmax])
#+end_src



* Step 4: Map predicted quantities into nutrients


Before this will work, need columns of qhat to match columns of fct.
#+begin_src jupyter-python
use = fct.index.intersection(qhat.columns)


nutrients = qhat[use]@fct.loc[use,:]
nutrients.mean()    # NB: Nutrients are for past /week/ for entire household. (Depends on dataset)
#+end_src

* Household Nutritional Adequacy

   Our data on demand and nutrients is at the /household/ level; we
   can't directly compare household level nutrition with individual
   level requirements.  What we *can* do is add up minimum individual
   requirements, and see whether household total exceed these.  This
   isn't a guarantee that all individuals have adequate nutrition
   (since the way food is allocated in the household might be quite
   unequal, or unrelated to individual requirements), but it is
   /necessary/ if all individuals are to have adequate nutrition.

   For each household, we know the numbers of people in different age-sex categories.  We can match these up with data from an RDI (Recommended Dietary Intakes), then sum over different types.
#+begin_src jupyter-python :results silent
z = z[rdi.columns.tolist()]

hh_rdi = z@rdi.T

# Uganda data is per week, so make this a recommended WEEKLY intake:
hh_rwi = hh_rdi*7
#+end_src

Now, what proportion of =hh_rwi= do households consume?
#+begin_src jupyter-python :results silent
# Match up nutrient names
use = nutrients.columns.intersection(hh_rwi.columns)

nutrient_ratio = (nutrients[use]/hh_rwi[use]).dropna()

nutrient_ratio
#+end_src

Graph ratios of adequacy for particular nutrients
#+begin_src jupyter-python :results silent

%matplotlib notebook
nutrient_ratio['Energy'].hist(bins=30)
#+end_src



* Step 7: Define Nutrient Demands :noexport:
  Define a convenience function to easily change one price at a time...
#+begin_src jupyter-python :results silent
def my_prices(p0,p=p,i='Coconut'):
    p = p.copy()
    p.loc[i] = p0
    return p
#+end_src

Of course, since we can compute the nutritional content of a vector of
consumption goods, we can also use our demand functions to
compute nutrition as a /function/ of prices and budget.  

#+begin_src jupyter-python
def nutrient_demand(x,p):
    c = r.demands(x,p)
    fct0,c0 = fct.align(c,axis=0,join='inner')
    N = fct0.T@c0

    return N
#+end_src


* Step 8: Counterfactual experiments :noexport:

With our estimated nutrient demand system, what happens to nutritional
outcomes if, say, all prices were to be scaled up or down?
#+begin_src jupyter-python
import numpy as np
import matplotlib.pyplot as plt
%matplotlib notebook

scale = np.linspace(.5,2,20)

# Total food expenditures per household
xbar = xhat.groupby(['i','t','m']).sum()
xbar.hist(bins=100)

# Reference budget
xref = xbar.quantile(0.5)  # Household at 0.5 quantile is median

# Reference prices
pbar = p.xs('2019-20',level='t').mean()
pbar = pbar[use]

plt.plot(scale,[nutrient_demand(xbar,pbar*s) for s in scale])

#+end_src
